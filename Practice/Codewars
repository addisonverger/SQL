--Challenges provided by Codewars: https://www.codewars.com/kata/search/sql?q=&beta=false&order_by=sort_date%20desc

--Even or Odd

SELECT number, CASE WHEN number % 2 = 0 THEN 'Even' ELSE 'Odd' END AS 'is_even'
FROM numbers;

--Hello SQL World!

SELECT 'hello world!' AS "Greeting"

--SQL: Right and Left

SELECT LEFT(project, commits) AS project, RIGHT(address, contributors) AS address
FROM repositories

--SQL: Concatenating Columns

SELECT CONCAT_WS(' ', prefix, first, last, suffix) AS title
FROM names

--SQL Basics: Maths with String Manipulations

SELECT BIT_LENGTH(name) + LENGTH(race) AS calculation
FROM demographics

--Maximum Multiple

SELECT CAST(FLOOR(bound / divisor) * divisor AS int) AS res
FROM max_multiple

--Disemvowel Trolls

SELECT str, TRANSLATE(str, 'aeiouAEIOU', '') AS res 
FROM disemvowel

--SQL Basics: Simple WITH

WITH special_sales AS (
  SELECT *
  FROM sales
  WHERE price > 90.00
)

SELECT id, name
FROM departments
WHERE id IN (SELECT department_id FROM special_sales)

--SQL Basics - Trimming the Field

SELECT 
  id, 
  name, 
  CASE
    WHEN POSITION(',' IN characteristics) <> 0
    THEN LEFT(characteristics, POSITION(',' IN characteristics) - 1) 
    ELSE characteristics
  END AS characteristic
FROM monsters
ORDER BY id

--GROCERY STORE: Inventory

SELECT id, name, stock
FROM products
WHERE producent = 'CompanyA'
AND stock <= 2
ORDER BY id

--Countries Capitals for Trivia Night (SQL for Beginners #6)

SELECT capital
FROM countries
WHERE continent IN ('Africa', 'Afrika')
AND country LIKE 'E%'
ORDER BY capital
LIMIT 3

--SQL Bug Fixing: Fix the JOIN

SELECT 
  DISTINCT j.job_title,
  CAST(ROUND(SUM(j.salary) / COUNT(p.id), 2) AS FLOAT) as average_salary,
  COUNT(p.id) as total_people,
  CAST(ROUND(SUM(j.salary), 2) AS FLOAT) as total_salary
FROM people p
JOIN job j
ON p.id = j.people_id
GROUP BY j.job_title
ORDER BY 2 DESC

--SQL Basics: Simple EXISTS

SELECT id, name
FROM departments d
WHERE EXISTS (
  SELECT department_id
  FROM sales s
  WHERE price > 98.00
  AND d.id = s.department_id
)

--Using LATERAL JOIN To Get Top N per Group

SELECT c.id AS category_id, c.category, p.title, p.views, p.post_id
FROM categories c
LEFT JOIN LATERAL (
  SELECT id AS post_id, category_id, title, views
  FROM posts 
  WHERE c.id = category_id
  ORDER BY views DESC, id
  LIMIT 2
) p
ON c.id = p.category_id
ORDER BY c.category, p.views DESC, p.post_id

--Counting overlapping events

SELECT v1.entry_time AS when_happened, COUNT(*) AS visits_count
FROM visits v1
JOIN visits v2
ON v1.entry_time >= v2.entry_time
AND v1.entry_time < v2.exit_time
GROUP BY v1.id
ORDER BY 2 DESC, 1
LIMIT 1

--SQL Basics: Simple PIVOTING data

CREATE EXTENSION tablefunc;

SELECT *
FROM CROSSTAB(
  'SELECT p.name, d.detail, COUNT(d.id)
  FROM products p
  JOIN details d
  ON p.id = d.product_id
  GROUP BY 1, 2
  ORDER BY 1'
)
AS ct (name TEXT, bad BIGINT, good BIGINT, ok BIGINT)

--Present JSON data the SQL way

SELECT
data->>'first_name' AS first_name,
data->>'last_name' AS last_name,
EXTRACT(YEAR FROM AGE(NOW(), (data->>'date_of_birth')::DATE))::INTEGER as age,
CASE
  WHEN data->>'private' = 'true'
  THEN 'Hidden'
  WHEN data->>'private' = 'false' AND data#>>'{email_addresses, 0}' IS NULL
  THEN 'None'
  ELSE data#>>'{email_addresses, 0}'
END AS email_address
FROM users
ORDER BY 1, 2

--Grasshopper - Terminal game move function

SELECT position, roll, position + roll * 2 AS res
FROM moves

--Is n divisible by x and y?

SELECT id, CASE WHEN n % x = 0 AND n % y = 0 THEN 1 ELSE 0 END as res
FROM kata

--Parameterized SQL: Section Access Control

prepare find_sections(int) as
  SELECT id, section_name
  FROM section_access
  WHERE $1 = ANY(REGEXP_SPLIT_TO_ARRAY(user_access,',')::int[])
  ORDER BY 1

--Genre Analysis with PostgreSQL Arrays

SELECT 
  UNNEST(genres) AS genre, 
  COUNT(*) AS count, 
  ARRAY_AGG(title ORDER BY title) AS books
FROM books
GROUP BY 1
ORDER BY 2 DESC, 1 ASC

--Hosts Missing Specific Software Title and Having Recent Installations

SELECT host 
FROM host_software 
GROUP BY host
HAVING EVERY(software_title <> 'Title2') 
AND MAX(install_date) >= CURRENT_DATE - INTERVAL '1 year'
ORDER BY host

--Beginner Series #1 School Paperwork

SELECT 
  n, 
  m,
  CASE
    WHEN n < 0 OR m < 0 THEN 0
    ELSE n * m
  END AS res
FROM paperwork

--Remove First and Last Character

SELECT s, RIGHT(LEFT(s, LENGTH(s) - 1), LENGTH(s) - 2) AS res
FROM removechar

--Cats and shelves

SELECT 
  a, 
  b,
  CAST(FLOOR((b - a) / 3) + ((b - a) % 3) AS INTEGER) AS res
FROM jumps

--Vowel Count

SELECT str, LENGTH(str) - LENGTH(TRANSLATE(str, 'aeiouAEIOU', '')) AS res
FROM getcount

--Quarter of the year

SELECT 
  month,
  CASE
    WHEN month BETWEEN 1 AND 3 THEN 1
    WHEN month BETWEEN 4 AND 6 THEN 2
    WHEN month BETWEEN 7 AND 9 THEN 3
    ELSE 4
  END AS res
FROM quarterof

--Expressions Matter

SELECT GREATEST(a + b * c, a * b + c, a * (b + c), (a + b) * c, a + b + c, a * b * c) AS res 
FROM expression_matter

--Century From Year

SELECT yr, CEILING(yr::DECIMAL / 100)::INTEGER AS century
FROM years

--Third Angle of a Triangle

SELECT a, b, 180-a-b AS res
FROM otherangle

--SQL Basics: Mod

SELECT number1 % number2 AS mod
FROM decimals

--Easy SQL: Square Root and Log

SELECT SQRT(number1) AS root, LOG(number2) AS log
FROM decimals

--Easy SQL: Rounding Decimals

SELECT FLOOR(number1) AS number1, CEILING(number2) AS number2
FROM decimals

--Easy SQL: Convert to Hexadecimal

SELECT TO_HEX(legs) AS legs, TO_HEX(arms) AS arms
FROM monsters

--Easy SQL: LowerCase

SELECT id, name, birthday, LOWER(race) AS race
FROM demographics

--Easy SQL - Ordering

SELECT *
FROM companies
ORDER BY employees DESC

--Count Odd Numbers below n

SELECT n, FLOOR(n / 2.0)::BIGINT AS res
FROM oddcount

--Get Nth Even Number

SELECT n, n * 2 - 2 AS res
FROM ntheven

--Adults only (SQL for Beginners #1)

SELECT name, age
FROM users
WHERE age >= 18

--On the Canadian Border (SQL for Beginners #2)

SELECT name, country
FROM travelers
WHERE country NOT IN ('Canada', 'Mexico', 'USA')

--Register for the Party (SQL for Beginners #3)

INSERT INTO participants VALUES ('Addison', 30, true);

SELECT * FROM participants;

--Collect Tuition (SQL for Beginners #4)

SELECT *
FROM students
WHERE tuition_received = false

--Will you make it?

SELECT 
  distance_to_pump, 
  mpg, 
  fuel_left, 
  CASE 
    WHEN mpg * fuel_left >= distance_to_pump THEN true 
    ELSE false 
  END AS res
FROM zerofuel

--Simple multiplication

SELECT 
  number, 
  CASE 
    WHEN number % 2 = 0 THEN number * 8 
    ELSE number * 9 
  END AS res
FROM multiplication

--Keep Hydrated!

SELECT id, hours, FLOOR(hours * 0.5) AS liters
FROM cycling

--SQL Grasshopper: Select Columns

SELECT custid, custname, custstate
FROM customers

--SQL Basics: Simple DISTINCT

SELECT DISTINCT age
FROM people

--SQL Basics: Simple MIN / MAX

SELECT MIN(age) AS age_min, MAX(age) AS age_max
FROM people

--SQL Basics: Simple SUM

SELECT SUM(age) AS age_sum
FROM people

--1. Find all active students

SELECT *
FROM students
WHERE isActive = 1

--SQL Basics: Simple WHERE and ORDER BY

SELECT *
FROM people
WHERE age > 50
ORDER BY age DESC

--Fake Binary

SELECT x, TRANSLATE(x, '123456789', '000011111') AS res 
FROM fakebin

--Remove String Spaces

SELECT x, REPLACE(x, ' ', '') AS res
FROM nospace

--Is it a palindrome?

SELECT 
  str,
  CASE
    WHEN LOWER(str) = REVERSE(LOWER(str)) THEN true
    ELSE false
  END AS res
FROM ispalindrome

--String repeat

SELECT s, n, REPEAT(s, n) AS res
FROM repeatstr

--Remove exclamation marks

SELECT s, REPLACE(s, '!', '') AS res
FROM removeexclamationmarks

--MakeUpperCase

SELECT s, UPPER(s) AS res
FROM makeuppercase

--Count the number of cubes with paint on

SELECT n, CASE WHEN n = 0 THEN 1 ELSE CAST(POWER(n + 1, 3) - POWER(n - 1, 3) AS INTEGER) END AS res
FROM squares

--Opposite number

SELECT number * -1 AS res
FROM opposite

--Never visit a . . . !?

SELECT 'apple' AS res 
FROM sub_sum

--Beginner Series #2 Clock

SELECT (h * 3600000) + (m * 60000) + (s * 1000) AS res 
FROM past

--Grasshopper - Messi goals function

SELECT la_liga_goals + copa_del_rey_goals + champions_league_goals AS res
FROM goals

--Grasshopper - Summation

SELECT n, (n + 1) * n / 2 AS res
FROM kata

--Grasshopper - Check for factor

SELECT id, base % factor = 0 AS res
FROM kata

--Returning Strings

SELECT 'Hello, ' || name || ' how are you doing today?' AS greeting
FROM person

--Opposites Attract

SELECT 
  flower1, 
  flower2, 
  CASE 
    WHEN flower1 % 2 = flower2 % 2 THEN false
    ELSE true
  END AS res
FROM love

--Convert boolean values to strings 'Yes' or 'No'.

SELECT 
  bool, 
  CASE 
    WHEN bool THEN 'Yes' 
    ELSE 'No' 
  END AS res
FROM booltoword

--Function 2 - squaring an argument

SELECT n, POWER(n, 2)::INT AS res
FROM square

--Reversed Strings

SELECT str, REVERSE(str) AS res
FROM solution

--Multiply

SELECT price * amount AS total FROM items

--Top-Scoring Students Across All Subjects

WITH max_rate AS (
  SELECT subject_id, MAX(mark_rate) AS max_mark
  FROM marks 
  GROUP BY subject_id
)

SELECT s.student_id, s.student_name
FROM students s
JOIN marks m
ON s.student_id = m.student_id
JOIN max_rate mr
ON m.subject_id = mr.subject_id
GROUP BY 1, 2
HAVING EVERY(m.mark_rate = mr.max_mark)
ORDER BY 1 DESC

--Top-Scoring Students for Each Subject

WITH max_marks_CTE AS (
  SELECT s.student_id, s.student_name, m.subject_id, subject_name, mark_rate
  FROM students s
  JOIN marks m
  ON s.student_id = m.student_id
  JOIN subjects sub 
  ON m.subject_id = sub.subject_id
  WHERE (m.subject_id, m.mark_rate) IN (
    SELECT subject_id, MAX(mark_rate) AS max_mark
    FROM marks
    GROUP BY 1
  )
)

SELECT ARRAY_AGG(student_name ORDER BY student_id) AS student_names, subject_name, mark_rate
FROM max_marks_CTE
GROUP BY subject_id, 2, 3
ORDER BY subject_id

--Centered pentagonal number

SELECT 
  n, 
  CASE WHEN n <= 0 THEN -1 ELSE ((5 * POWER(n, 2) - 5 * n + 2) / 2)::BIGINT END AS res
FROM pentagonal

--Count up the points for the 7 Wonders board game! Easy version

SELECT 
  id, 
  compasses, 
  gears, 
  tablets,
  (LEAST(compasses, gears, tablets) * 7 + POWER(compasses, 2) + POWER(gears, 2) + POWER(tablets, 2))::INT AS res
FROM seven_wonders_science

--SQL with LOTR: Elven Wildcards

SELECT INITCAP(firstname || ' ' || lastname) AS shortlist
FROM elves
WHERE firstname LIKE '%tegil%'
OR lastname LIKE '%astar%'

--SQL with Street Fighter: Total Wins

SELECT name, SUM(won) AS won, SUM(lost) AS lost
FROM fighters f
JOIN winning_moves w
ON f.move_id = w.id
WHERE w.move NOT IN ('Hadoken', 'Shouoken', 'Kikoken')
GROUP BY name
ORDER BY 2 DESC
LIMIT 6

--SQL with Harry Potter: Sorting Hat Comparators

SELECT *
FROM students
WHERE (quality1 = 'evil' AND quality2 = 'cunning')
OR (quality1 = 'brave' AND quality2 <> 'evil')
OR (quality1 = 'studious' OR quality2 = 'intelligent')
OR (quality1 = 'hufflepuff' OR quality2 = 'hufflepuff')
ORDER BY id ASC

--SQL with Pokemon: Damage Multipliers

SELECT pokemon_name, str * multiplier AS modifiedStrength, element
FROM pokemon p
JOIN multipliers m
ON p.element_id = m.id
WHERE str * multiplier >= 40
ORDER BY 2 DESC

--SQL with Sailor Moon: Thinking about JOINs...

SELECT senshi_name AS sailor_senshi, real_name_jpn AS real_name, name AS cat, school
FROM sailorsenshi ss
LEFT JOIN cats c
ON ss.cat_id = c.id
LEFT JOIN schools s
ON ss.school_id = s.id

--GROCERY STORE: Real Price!

SELECT name, weight, price, ROUND((price * 1000 / weight)::NUMERIC, 2)::FLOAT AS price_per_kg
FROM products
ORDER BY 4 ASC, 1 ASC

--GROCERY STORE: Support Local Products

SELECT COUNT(*) AS products, country
FROM products
WHERE country IN ('United States of America', 'Canada')
GROUP BY country
ORDER BY 1 DESC

--GROCERY STORE: Logistic Optimisation

SELECT COUNT(*) AS count_products_types, producer
FROM products
GROUP BY producer
ORDER BY 1 DESC, 2 ASC

--BASICS: Length based SELECT with LIKE

SELECT first_name, last_name
FROM names
WHERE first_name LIKE '______%'

--Sum of angles

SELECT (n - 2) * 180 AS res 
FROM angle

--SQL: Disorder

SELECT number
FROM numbers
ORDER BY RANDOM()

--SQL Basics: Up and Down

SELECT 
  CASE
    WHEN SUM(number1) % 2 <> 0 THEN MIN(number1)
    ELSE MAX(number1)
  END AS number1,
  CASE
    WHEN SUM(number2) % 2 <> 0 THEN MIN(number2)
    ELSE MAX(number2)
  END AS number2
FROM numbers

--SQL Basics: Truncating

SELECT TRUNC(number1 + number2) AS towardzero
FROM decimals

--SQL Basics: Raise to the Power

SELECT POWER(number1, number2) AS result
FROM decimals

--Easy SQL: Absolute Value and Log to Base

SELECT ABS(number1) AS abs, LOG(64, number2) AS log
FROM decimals

--Easy SQL: Cube Root and Natural Log

SELECT CBRT(number1) AS cuberoot, LN(number2) AS logarithm
FROM decimals

--Easy SQL: Moving Values

SELECT 
  LENGTH(name::TEXT) AS id,
  LENGTH(legs::TEXT) AS name,
  LENGTH(arms::TEXT) AS legs,
  LENGTH(characteristics::TEXT) AS arms,
  LENGTH(id::TEXT) AS characteristics
FROM monsters

--SQL: Bytes in String from Ints

SELECT 
  OCTET_LENGTH(number1::TEXT) AS octnum1,
  OCTET_LENGTH(number2::TEXT) AS octnum2,
  OCTET_LENGTH(number3::TEXT) AS octnum3,
  OCTET_LENGTH(number4::TEXT) AS octnum4,
  OCTET_LENGTH(number5::TEXT) AS octnum5
FROM numbers

--Easy SQL: Bit Length

SELECT 
  id,
  BIT_LENGTH(name) AS name,
  birthday,
  BIT_LENGTH(race) AS race
FROM demographics

--Easy SQL: ASCII Converter

SELECT
  id,
  ASCII(name) AS name,
  birthday,
  ASCII(race) AS race
FROM demographics

--Easy SQL: Counting and Grouping

SELECT race, COUNT(*) AS count
FROM demographics
GROUP BY 1
ORDER BY 2 DESC

--SQL: Padding Encryption

SELECT 
  md5 || REPEAT('1', LENGTH(sha256) - LENGTH(md5)) AS md5,
  REPEAT('0', LENGTH(sha256) - LENGTH(sha1)) || sha1 AS sha1,
  sha256
FROM encryption

--SQL: Regex Replace

SELECT
  project,
  commits,
  contributors,
  REGEXP_REPLACE(address,'[[:digit:]]','!','g') AS address
FROM repositories

--SQL Basics: Repeat and Reverse

SELECT REPEAT(name, 3) AS name, REVERSE(characteristics) AS characteristics
FROM monsters

--SQL Basics - Position

SELECT id, name, POSITION(',' IN characteristics) AS comma
FROM monsters
ORDER BY comma

--Best-Selling Books (SQL for Beginners #5)

SELECT name, author, copies_sold
FROM books
ORDER BY 3 DESC
LIMIT 5

--Simple Fun #74: Growing Plant

SELECT 
  ROW_NUMBER() OVER(ORDER BY (SELECT NULL)) AS id,
  CASE
    WHEN desired_height <= up_speed THEN 1
    ELSE CEIL((desired_height - up_speed)::DEC / (up_speed - down_speed))::INT + 1 
  END AS num_days
FROM growing_plant

--SQL Basics: Simple GROUP BY

SELECT age, COUNT(id) AS people_count
FROM people
GROUP BY age

--SQL Basics: Create a FUNCTION

CREATE FUNCTION increment(i integer)
  RETURNS integer 
  LANGUAGE plpgsql
AS 
$$
BEGIN
  RETURN i + 1;
END;  
$$;

--SQL Basics: Simple JOIN with COUNT

SELECT p.id, p.name, COUNT(t.id) AS toy_count
FROM people p
JOIN toys t
ON p.id = t.people_id
GROUP BY 1, 2

--Sum of Triangular Numbers

SELECT 
  n, 
  CASE
    WHEN n < 0 THEN 0
    ELSE (n * (n + 1) * (n + 2)) / 6
  END AS res
FROM sumtriangular

--SQL Basics: Simple JOIN

SELECT p.*, c.name AS company_name
FROM products p
JOIN companies c
ON p.company_id = c.id

--Complementary DNA

SELECT dna, TRANSLATE(dna, 'ATGC', 'TACG') AS res
FROM dnastrand

--Triangular Treasure

SELECT 
  n, 
  CASE
    WHEN n <= 0 THEN 0
    ELSE (n * (n + 1)) / 2 
  END AS res
FROM triangular

--Finding Duplicate Product Codes Across Different Groups

SELECT product_id, group_id, product_code
FROM (
  SELECT DISTINCT p1.*, RANK() OVER (PARTITION BY p1.group_id, p1.product_code ORDER BY p1.product_id DESC) AS rnk
  FROM products p1
  JOIN products p2
  ON p1.product_code = p2.product_code
  AND p1.group_id <> p2.group_id
) x
WHERE rnk = 1
ORDER BY product_code ASC, group_id DESC

--Calculate Total Downtime for Machines

WITH CTE AS (
  SELECT machine_id, load_id, start_time, LAG(end_time) OVER (PARTITION BY machine_id ORDER BY end_time) AS lag
  FROM process_times
)

SELECT machine_id, EXTRACT(EPOCH FROM SUM(start_time - lag)) * INTERVAL '1 sec' AS total_down_time
FROM CTE
GROUP BY machine_id
HAVING SUM(start_time - lag) IS NOT NULL
ORDER BY 1 DESC

--Ranking based on Town and Property Type Combinations

SELECT
  DENSE_RANK() OVER (ORDER BY town ASC, property_type ASC) AS rank_order,
  town,
  property_type,
  c.customer_id,
  order_id
FROM customer_preferences c
LEFT JOIN order_info o
ON c.customer_id = o.customer_id
ORDER BY 1, 4, 5

--Customer Rebates Based on Total Orders for September 2023

SELECT
  o.customer_id,
  o.total_orders,
  MAX(r.rebate_percentage) AS rebate_percentage
FROM (
  SELECT customer_id, SUM(order_amount) AS total_orders
  FROM orders
  WHERE EXTRACT(YEAR FROM order_date) = 2023
  AND EXTRACT(MONTH FROM order_date) = 09
  GROUP BY 1) o
JOIN rebates r
ON o.total_orders >= r.min_purchase
GROUP BY 1, 2
ORDER BY 1 DESC

--Conditional Grouping of User Activities

SELECT *
FROM (
  SELECT
    CASE
      WHEN username SIMILAR TO 'User[0-9]+' THEN 'GROUP_OTHERS'
      ELSE username
    END AS username,
    SUM(activity_count) AS total_activity
  FROM (SELECT * FROM user_activity WHERE activity_count BETWEEN 1 AND 2000) x
  GROUP BY 1
) y
ORDER BY CASE WHEN username = 'GROUP_OTHERS' THEN 0 ELSE 1 END, username ASC

--Next Greater Or Equal Ordered Quantities for Specified Thresholds

WITH CTE AS (
  SELECT
    ROW_NUMBER() OVER (PARTITION BY i.order_id, i.threshold_quantity ORDER BY p.quantity ASC) AS row_number,
    i.order_id, 
    i.threshold_quantity, 
    p.quantity AS next_ge_quantity, 
    p.product_name 
  FROM inventory_thresholds i
  LEFT JOIN product_orders p
  ON i.order_id = p.order_id 
  AND i.threshold_quantity <= p.quantity
)

SELECT order_id, threshold_quantity, next_ge_quantity, product_name
FROM CTE
WHERE row_number = 1

--Constructing a Student-Course Relationship Map

WITH CTE AS (
  SELECT 
      s.student_id,
      c.course_id,
      s.name || ' (' || s.student_id || ')' AS student,
      c.course_name || ' (' || c.course_id || ')' AS course
    FROM (
      SELECT *
      FROM students
      WHERE student_id IN (SELECT student_id FROM enrollments)
    ) s
    CROSS JOIN (
      SELECT *
      FROM courses
      WHERE course_id IN (SELECT course_id FROM enrollments)
    ) c
    ORDER BY s.student_id, c.course_id
)

SELECT 
  x.student, 
  x.course, 
  CASE 
    WHEN e.student_id IS NULL THEN 0 
    ELSE 1
  END AS is_exists
FROM CTE x
LEFT JOIN enrollments e
ON x.student_id = e.student_id
AND x.course_id = e.course_id

--Segmented Range Extraction from Boundary Markers

WITH CTE AS (
  SELECT category, range, ROW_NUMBER() OVER (ORDER BY range) AS rn
  FROM categories
)

SELECT x.category, x.range AS start_range, MIN(y.range) AS end_range
FROM (
  SELECT category, range
  FROM CTE
  WHERE rn % 2 <> 0
) x
JOIN (
  SELECT category, range
  FROM CTE
  WHERE rn % 2 = 0
) y
ON x.category = y.category
AND x.range < y.range
GROUP BY 1, 2
ORDER BY 2

--Identify and Exclude Reversed Fuel Transactions

WITH CTE AS (
  SELECT MAX(id_1) AS id_1, id_2
  FROM(
    SELECT f1.transaction_id AS id_1, MIN(f2.transaction_id) AS id_2
    FROM fuel_transactions f1
    JOIN fuel_transactions f2
    ON f1.fuel_type = f2.fuel_type
    AND f1.quantity = - f2.quantity
    AND f1.transaction_datetime < f2.transaction_datetime
    AND f1.is_reversal = 'N'
    GROUP BY 1
  ) x
  GROUP BY 2
)

SELECT *
FROM fuel_transactions 
WHERE transaction_id NOT IN (
  SELECT id_1 FROM CTE 
  UNION ALL 
  SELECT id_2 FROM CTE
)

--Customer Orders: Products 1 & 2, Excluding 3

SELECT 
  c.customer_id, 
  c.name, 
  'Product 1: ' || COUNT(*) FILTER (WHERE o.product_name = 'Product 1') || ' times || Product 2: ' || COUNT(*) FILTER (WHERE o.product_name = 'Product 2') || ' times' AS product_summary
FROM customers c
JOIN orders o
ON c.customer_id = o.customer_id
WHERE c.customer_id NOT IN (
  SELECT customer_id
  FROM orders
  WHERE product_name = 'Product 3'
)
GROUP BY 1, 2
HAVING COUNT(*) FILTER (WHERE o.product_name = 'Product 1') > 0
AND COUNT(*) FILTER (WHERE o.product_name = 'Product 2') > 0
ORDER BY 1 DESC

--Grouping and Numbering Shipments Based on Status Codes

SELECT 
  order_id,
  product_name,
  status_code,
  CASE
    WHEN reset = 0 THEN 0
    ELSE COUNT(*) OVER (PARTITION BY reset ORDER BY order_id)
  END AS shipment_batch_number
FROM (
  SELECT 
    *, 
    COUNT(status_code = 4 OR NULL) OVER (ORDER BY order_id) AS reset 
  FROM order_status
) x
ORDER BY order_id

--Extracting and Ranking Unique Tags

SELECT
  RANK() OVER (ORDER BY tag_count DESC, tag ASC) AS tag_rank,
  tag,
  tag_count
FROM (
  SELECT 
    UNNEST(STRING_TO_ARRAY(tags, ',')) AS tag,
    COUNT(*) AS tag_count
  FROM user_tags
  GROUP BY 1
) x

--Flexible Sum Based on Operations

SELECT 
  id, 
  operation, 
  amount, 
  date, 
  SUM(adjusted_amount) OVER (ORDER BY date, id) AS flexible_sum
FROM (
  SELECT
    *,
    CASE
      WHEN operation = 'add' THEN amount
      WHEN operation = 'remove' THEN -amount
      ELSE 0
    END AS adjusted_amount
  FROM transactions
) x
ORDER BY 4, 1

--Tracking Last Large Transactions

SELECT 
  a1.*,
  MAX(a2.date) AS last_over_hundred
FROM account_transactions a1
LEFT JOIN account_transactions a2
ON a2.account_id = a1.account_id
AND a1.date >= a2.date
AND a2.amount > 100
GROUP BY 1, 2, 3
ORDER BY a1.account_id DESC, a1.date ASC

--Books That Have Been Out for the Longest Duration

WITH CTE AS (
  SELECT
    b.book_id,
    b.title,
    b.author,
    l.loan_id,
    l.borrower_name,
    COALESCE(l.return_date, CURRENT_DATE) - LAG(COALESCE(l.return_date, CURRENT_DATE)) OVER (PARTITION BY b.book_id ORDER BY COALESCE(l.return_date, CURRENT_DATE)) AS borrow_diff
  FROM books b
  JOIN loans l
  ON b.book_id = l.book_id
)

SELECT
  book_id,
  title,
  author,
  loan_id,
  borrower_name,
  borrow_diff || ' Days' AS longest_borrow_interval
FROM CTE
GROUP BY 1, 2, 3, 4, 5, borrow_diff
HAVING borrow_diff = (SELECT MAX(borrow_diff) FROM CTE)
ORDER BY 4 ASC

--Most Borrowed Books and Their Last Borrowers

WITH CTE AS (
  SELECT 
    b.book_id, 
    b.title, 
    l.borrower_name, 
    l.return_date, 
    COUNT(l.loan_id) OVER (PARTITION BY b.book_id) AS loan_count,
    ROW_NUMBER() OVER (PARTITION BY b.book_id ORDER BY return_date DESC) AS return_order
  FROM books b
  JOIN loans l
  ON b.book_id = l.book_id
)

SELECT book_id, title, borrower_name AS last_borrower, loan_count
FROM CTE
WHERE loan_count = (SELECT MAX(loan_count) FROM CTE)
AND return_order = 1

--Rolling Window Analysis of Customer Visits

SELECT
  date,
  customer_id,
  name,
  (SELECT COUNT(DISTINCT c2.name) 
    FROM customers c2 
    WHERE c1.customer_id = c2.customer_id 
    AND c2.date BETWEEN c1.date - 2 AND c1.date) AS count
FROM customers c1
ORDER BY 1, 2 DESC, 3

--Forward Filling of Missing Data

SELECT
  day,
  FIRST_VALUE(sales) OVER (PARTITION BY sales_partition ORDER BY day) AS filled_sales
FROM (
  SELECT
    day,
    sales,
    SUM(CASE WHEN sales IS NULL THEN 0 ELSE 1 END) OVER (ORDER BY day) AS sales_partition
  FROM sales_data
) x

--Days to Reach a Cumulative Transaction Threshold

SELECT
  id,
  date,
  amount,
  CASE
    WHEN running_sum < 15
    THEN NULL
    ELSE date - min_date
  END AS days_to_reach_threshold
FROM (
  SELECT
    id,
    date,
    amount,
    SUM(amount) OVER (ORDER BY date) AS running_sum,
    MIN(date) OVER () AS min_date
  FROM transactions
) x
WHERE running_sum - amount < 15
ORDER BY date ASC

--Backend Team's Tradition: An Age-Alternating Introduction

SELECT *
FROM employees 
WHERE team = 'backend' 
ORDER BY LEAST(
  2 * ROW_NUMBER() OVER (ORDER BY birth_date DESC) - 1,
  2 * ROW_NUMBER() OVER (ORDER BY birth_date ASC)
)

--Generation Categorization

CREATE TEMPORARY TABLE generational_categories (
  id SERIAL PRIMARY KEY, 
  generation_name VARCHAR,
  from_date INT,
  to_date INT
);

INSERT INTO generational_categories(generation_name, from_date, to_date)
VALUES ('Generation Z', 1997, 2012),
('Millennials', 1981, 1996),
('Generation X', 1965, 1980),
('Baby Boomers', 1946, 1964),
('Silent Generation', 1928, 1945),
('Greatest Generation', 0, 1927);

SELECT *, 
  (SELECT generation_name 
   FROM generational_categories 
   WHERE EXTRACT(YEAR FROM users.birthdate) BETWEEN from_date AND to_date) AS generation
FROM users
ORDER BY id ASC;

--User Classification With a Twist

WITH b_CTE AS (
  SELECT DISTINCT user_id, class
  FROM users
  WHERE class = 'b'
), a_CTE AS (
  SELECT DISTINCT user_id, class
  FROM (
    SELECT *
    FROM users
    WHERE class = 'a'
  ) a
  WHERE user_id 
  NOT IN (SELECT user_id FROM b_CTE)
)

SELECT class, COUNT(*) FROM a_CTE GROUP BY 1
UNION ALL
SELECT class, COUNT(*) FROM b_CTE GROUP BY 1
