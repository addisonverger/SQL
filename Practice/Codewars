--Challenges provided by Codewars: https://www.codewars.com/kata/search/sql?q=&beta=false&order_by=sort_date%20desc

--Even or Odd

SELECT number, CASE WHEN number % 2 = 0 THEN 'Even' ELSE 'Odd' END AS 'is_even'
FROM numbers;

--Hello SQL World!

SELECT 'hello world!' AS "Greeting"

--SQL: Right and Left

SELECT LEFT(project, commits) AS project, RIGHT(address, contributors) AS address
FROM repositories

--SQL: Concatenating Columns

SELECT CONCAT_WS(' ', prefix, first, last, suffix) AS title
FROM names

--SQL Basics: Maths with String Manipulations

SELECT BIT_LENGTH(name) + LENGTH(race) AS calculation
FROM demographics

--Maximum Multiple

SELECT CAST(FLOOR(bound / divisor) * divisor AS int) AS res
FROM max_multiple

--Disemvowel Trolls

SELECT str, TRANSLATE(str, 'aeiouAEIOU', '') AS res 
FROM disemvowel

--SQL Basics: Simple WITH

WITH special_sales AS (
  SELECT *
  FROM sales
  WHERE price > 90.00
)

SELECT id, name
FROM departments
WHERE id IN (SELECT department_id FROM special_sales)

--SQL Basics - Trimming the Field

SELECT 
  id, 
  name, 
  CASE
    WHEN POSITION(',' IN characteristics) <> 0
    THEN LEFT(characteristics, POSITION(',' IN characteristics) - 1) 
    ELSE characteristics
  END AS characteristic
FROM monsters
ORDER BY id

--GROCERY STORE: Inventory

SELECT id, name, stock
FROM products
WHERE producent = 'CompanyA'
AND stock <= 2
ORDER BY id

--Countries Capitals for Trivia Night (SQL for Beginners #6)

SELECT capital
FROM countries
WHERE continent IN ('Africa', 'Afrika')
AND country LIKE 'E%'
ORDER BY capital
LIMIT 3

--SQL Bug Fixing: Fix the JOIN

SELECT 
  DISTINCT j.job_title,
  CAST(ROUND(SUM(j.salary) / COUNT(p.id), 2) AS FLOAT) as average_salary,
  COUNT(p.id) as total_people,
  CAST(ROUND(SUM(j.salary), 2) AS FLOAT) as total_salary
FROM people p
JOIN job j
ON p.id = j.people_id
GROUP BY j.job_title
ORDER BY 2 DESC

--SQL Basics: Simple EXISTS

SELECT id, name
FROM departments d
WHERE EXISTS (
  SELECT department_id
  FROM sales s
  WHERE price > 98.00
  AND d.id = s.department_id
)

--Using LATERAL JOIN To Get Top N per Group

SELECT c.id AS category_id, c.category, p.title, p.views, p.post_id
FROM categories c
LEFT JOIN LATERAL (
  SELECT id AS post_id, category_id, title, views
  FROM posts 
  WHERE c.id = category_id
  ORDER BY views DESC, id
  LIMIT 2
) p
ON c.id = p.category_id
ORDER BY c.category, p.views DESC, p.post_id

--Counting overlapping events

SELECT v1.entry_time AS when_happened, COUNT(*) AS visits_count
FROM visits v1
JOIN visits v2
ON v1.entry_time >= v2.entry_time
AND v1.entry_time < v2.exit_time
GROUP BY v1.id
ORDER BY 2 DESC, 1
LIMIT 1

--SQL Basics: Simple PIVOTING data

CREATE EXTENSION tablefunc;

SELECT *
FROM CROSSTAB(
  'SELECT p.name, d.detail, COUNT(d.id)
  FROM products p
  JOIN details d
  ON p.id = d.product_id
  GROUP BY 1, 2
  ORDER BY 1'
)
AS ct (name TEXT, bad BIGINT, good BIGINT, ok BIGINT)

--Present JSON data the SQL way

SELECT
data->>'first_name' AS first_name,
data->>'last_name' AS last_name,
EXTRACT(YEAR FROM AGE(NOW(), (data->>'date_of_birth')::DATE))::INTEGER as age,
CASE
  WHEN data->>'private' = 'true'
  THEN 'Hidden'
  WHEN data->>'private' = 'false' AND data#>>'{email_addresses, 0}' IS NULL
  THEN 'None'
  ELSE data#>>'{email_addresses, 0}'
END AS email_address
FROM users
ORDER BY 1, 2

--Grasshopper - Terminal game move function

SELECT position, roll, position + roll * 2 AS res
FROM moves

--Is n divisible by x and y?

SELECT id, CASE WHEN n % x = 0 AND n % y = 0 THEN 1 ELSE 0 END as res
FROM kata

--Parameterized SQL: Section Access Control

prepare find_sections(int) as
  SELECT id, section_name
  FROM section_access
  WHERE $1 = ANY(REGEXP_SPLIT_TO_ARRAY(user_access,',')::int[])
  ORDER BY 1

--Genre Analysis with PostgreSQL Arrays

SELECT 
  UNNEST(genres) AS genre, 
  COUNT(*) AS count, 
  ARRAY_AGG(title ORDER BY title) AS books
FROM books
GROUP BY 1
ORDER BY 2 DESC, 1 ASC

--Hosts Missing Specific Software Title and Having Recent Installations

SELECT host 
FROM host_software 
GROUP BY host
HAVING EVERY(software_title <> 'Title2') 
AND MAX(install_date) >= CURRENT_DATE - INTERVAL '1 year'
ORDER BY host

--Beginner Series #1 School Paperwork

SELECT 
  n, 
  m,
  CASE
    WHEN n < 0 OR m < 0 THEN 0
    ELSE n * m
  END AS res
FROM paperwork

--Remove First and Last Character

SELECT s, RIGHT(LEFT(s, LENGTH(s) - 1), LENGTH(s) - 2) AS res
FROM removechar

--Cats and shelves

SELECT 
  a, 
  b,
  CAST(FLOOR((b - a) / 3) + ((b - a) % 3) AS INTEGER) AS res
FROM jumps

--Vowel Count

SELECT str, LENGTH(str) - LENGTH(TRANSLATE(str, 'aeiouAEIOU', '')) AS res
FROM getcount

--Quarter of the year

SELECT 
  month,
  CASE
    WHEN month BETWEEN 1 AND 3 THEN 1
    WHEN month BETWEEN 4 AND 6 THEN 2
    WHEN month BETWEEN 7 AND 9 THEN 3
    ELSE 4
  END AS res
FROM quarterof

--Expressions Matter

SELECT GREATEST(a + b * c, a * b + c, a * (b + c), (a + b) * c, a + b + c, a * b * c) AS res 
FROM expression_matter

--Century From Year

SELECT yr, CEILING(yr::DECIMAL / 100)::INTEGER AS century
FROM years

--Third Angle of a Triangle

SELECT a, b, 180-a-b AS res
FROM otherangle

--SQL Basics: Mod

SELECT number1 % number2 AS mod
FROM decimals

--Easy SQL: Square Root and Log

SELECT SQRT(number1) AS root, LOG(number2) AS log
FROM decimals

--Easy SQL: Rounding Decimals

SELECT FLOOR(number1) AS number1, CEILING(number2) AS number2
FROM decimals

--Easy SQL: Convert to Hexadecimal

SELECT TO_HEX(legs) AS legs, TO_HEX(arms) AS arms
FROM monsters

--Easy SQL: LowerCase

SELECT id, name, birthday, LOWER(race) AS race
FROM demographics

--Easy SQL - Ordering

SELECT *
FROM companies
ORDER BY employees DESC

--Count Odd Numbers below n

SELECT n, FLOOR(n / 2.0)::BIGINT AS res
FROM oddcount

--Get Nth Even Number

SELECT n, n * 2 - 2 AS res
FROM ntheven

--Adults only (SQL for Beginners #1)

SELECT name, age
FROM users
WHERE age >= 18

--On the Canadian Border (SQL for Beginners #2)

SELECT name, country
FROM travelers
WHERE country NOT IN ('Canada', 'Mexico', 'USA')

--Register for the Party (SQL for Beginners #3)

INSERT INTO participants VALUES ('Addison', 30, true);

SELECT * FROM participants;

--Collect Tuition (SQL for Beginners #4)

SELECT *
FROM students
WHERE tuition_received = false

--Will you make it?

SELECT 
  distance_to_pump, 
  mpg, 
  fuel_left, 
  CASE 
    WHEN mpg * fuel_left >= distance_to_pump THEN true 
    ELSE false 
  END AS res
FROM zerofuel

--Simple multiplication

SELECT 
  number, 
  CASE 
    WHEN number % 2 = 0 THEN number * 8 
    ELSE number * 9 
  END AS res
FROM multiplication

--Keep Hydrated!

SELECT id, hours, FLOOR(hours * 0.5) AS liters
FROM cycling

--SQL Grasshopper: Select Columns

SELECT custid, custname, custstate
FROM customers

--SQL Basics: Simple DISTINCT

SELECT DISTINCT age
FROM people

--SQL Basics: Simple MIN / MAX

SELECT MIN(age) AS age_min, MAX(age) AS age_max
FROM people

--SQL Basics: Simple SUM

SELECT SUM(age) AS age_sum
FROM people

--1. Find all active students

SELECT *
FROM students
WHERE isActive = 1

--SQL Basics: Simple WHERE and ORDER BY

SELECT *
FROM people
WHERE age > 50
ORDER BY age DESC

--Fake Binary

SELECT x, TRANSLATE(x, '123456789', '000011111') AS res 
FROM fakebin

--Remove String Spaces

SELECT x, REPLACE(x, ' ', '') AS res
FROM nospace

--Is it a palindrome?

SELECT 
  str,
  CASE
    WHEN LOWER(str) = REVERSE(LOWER(str)) THEN true
    ELSE false
  END AS res
FROM ispalindrome

--String repeat

SELECT s, n, REPEAT(s, n) AS res
FROM repeatstr

--Remove exclamation marks

SELECT s, REPLACE(s, '!', '') AS res
FROM removeexclamationmarks

--MakeUpperCase

SELECT s, UPPER(s) AS res
FROM makeuppercase

--Count the number of cubes with paint on

SELECT n, CASE WHEN n = 0 THEN 1 ELSE CAST(POWER(n + 1, 3) - POWER(n - 1, 3) AS INTEGER) END AS res
FROM squares

--Opposite number

SELECT number * -1 AS res
FROM opposite

--Never visit a . . . !?

SELECT 'apple' AS res 
FROM sub_sum

--Beginner Series #2 Clock

SELECT (h * 3600000) + (m * 60000) + (s * 1000) AS res 
FROM past

--Grasshopper - Messi goals function

SELECT la_liga_goals + copa_del_rey_goals + champions_league_goals AS res
FROM goals

--Grasshopper - Summation

SELECT n, (n + 1) * n / 2 AS res
FROM kata

--Grasshopper - Check for factor

SELECT id, base % factor = 0 AS res
FROM kata

--Returning Strings

SELECT 'Hello, ' || name || ' how are you doing today?' AS greeting
FROM person

--Opposites Attract

SELECT 
  flower1, 
  flower2, 
  CASE 
    WHEN flower1 % 2 = flower2 % 2 THEN false
    ELSE true
  END AS res
FROM love

--Convert boolean values to strings 'Yes' or 'No'.

SELECT 
  bool, 
  CASE 
    WHEN bool THEN 'Yes' 
    ELSE 'No' 
  END AS res
FROM booltoword

--Function 2 - squaring an argument

SELECT n, POWER(n, 2)::INT AS res
FROM square

--Reversed Strings

SELECT str, REVERSE(str) AS res
FROM solution

--Multiply

SELECT price * amount AS total FROM items

--Top-Scoring Students Across All Subjects

WITH max_rate AS (
  SELECT subject_id, MAX(mark_rate) AS max_mark
  FROM marks 
  GROUP BY subject_id
)

SELECT s.student_id, s.student_name
FROM students s
JOIN marks m
ON s.student_id = m.student_id
JOIN max_rate mr
ON m.subject_id = mr.subject_id
GROUP BY 1, 2
HAVING EVERY(m.mark_rate = mr.max_mark)
ORDER BY 1 DESC

--Top-Scoring Students for Each Subject

WITH max_marks_CTE AS (
  SELECT s.student_id, s.student_name, m.subject_id, subject_name, mark_rate
  FROM students s
  JOIN marks m
  ON s.student_id = m.student_id
  JOIN subjects sub 
  ON m.subject_id = sub.subject_id
  WHERE (m.subject_id, m.mark_rate) IN (
    SELECT subject_id, MAX(mark_rate) AS max_mark
    FROM marks
    GROUP BY 1
  )
)

SELECT ARRAY_AGG(student_name ORDER BY student_id) AS student_names, subject_name, mark_rate
FROM max_marks_CTE
GROUP BY subject_id, 2, 3
ORDER BY subject_id

--Centered pentagonal number

SELECT 
  n, 
  CASE WHEN n <= 0 THEN -1 ELSE ((5 * POWER(n, 2) - 5 * n + 2) / 2)::BIGINT END AS res
FROM pentagonal

--Count up the points for the 7 Wonders board game! Easy version

SELECT 
  id, 
  compasses, 
  gears, 
  tablets,
  (LEAST(compasses, gears, tablets) * 7 + POWER(compasses, 2) + POWER(gears, 2) + POWER(tablets, 2))::INT AS res
FROM seven_wonders_science

--SQL with LOTR: Elven Wildcards

SELECT INITCAP(firstname || ' ' || lastname) AS shortlist
FROM elves
WHERE firstname LIKE '%tegil%'
OR lastname LIKE '%astar%'

--SQL with Street Fighter: Total Wins

SELECT name, SUM(won) AS won, SUM(lost) AS lost
FROM fighters f
JOIN winning_moves w
ON f.move_id = w.id
WHERE w.move NOT IN ('Hadoken', 'Shouoken', 'Kikoken')
GROUP BY name
ORDER BY 2 DESC
LIMIT 6

--SQL with Harry Potter: Sorting Hat Comparators

SELECT *
FROM students
WHERE (quality1 = 'evil' AND quality2 = 'cunning')
OR (quality1 = 'brave' AND quality2 <> 'evil')
OR (quality1 = 'studious' OR quality2 = 'intelligent')
OR (quality1 = 'hufflepuff' OR quality2 = 'hufflepuff')
ORDER BY id ASC

--SQL with Pokemon: Damage Multipliers

SELECT pokemon_name, str * multiplier AS modifiedStrength, element
FROM pokemon p
JOIN multipliers m
ON p.element_id = m.id
WHERE str * multiplier >= 40
ORDER BY 2 DESC

--SQL with Sailor Moon: Thinking about JOINs...

SELECT senshi_name AS sailor_senshi, real_name_jpn AS real_name, name AS cat, school
FROM sailorsenshi ss
LEFT JOIN cats c
ON ss.cat_id = c.id
LEFT JOIN schools s
ON ss.school_id = s.id

--GROCERY STORE: Real Price!

SELECT name, weight, price, ROUND((price * 1000 / weight)::NUMERIC, 2)::FLOAT AS price_per_kg
FROM products
ORDER BY 4 ASC, 1 ASC

--GROCERY STORE: Support Local Products

SELECT COUNT(*) AS products, country
FROM products
WHERE country IN ('United States of America', 'Canada')
GROUP BY country
ORDER BY 1 DESC

--GROCERY STORE: Logistic Optimisation

SELECT COUNT(*) AS count_products_types, producer
FROM products
GROUP BY producer
ORDER BY 1 DESC, 2 ASC

--BASICS: Length based SELECT with LIKE

SELECT first_name, last_name
FROM names
WHERE first_name LIKE '______%'

--Sum of angles

SELECT (n - 2) * 180 AS res 
FROM angle

--SQL: Disorder

SELECT number
FROM numbers
ORDER BY RANDOM()

--SQL Basics: Up and Down

SELECT 
  CASE
    WHEN SUM(number1) % 2 <> 0 THEN MIN(number1)
    ELSE MAX(number1)
  END AS number1,
  CASE
    WHEN SUM(number2) % 2 <> 0 THEN MIN(number2)
    ELSE MAX(number2)
  END AS number2
FROM numbers

--SQL Basics: Truncating

SELECT TRUNC(number1 + number2) AS towardzero
FROM decimals

--SQL Basics: Raise to the Power

SELECT POWER(number1, number2) AS result
FROM decimals

--Easy SQL: Absolute Value and Log to Base

SELECT ABS(number1) AS abs, LOG(64, number2) AS log
FROM decimals

--Easy SQL: Cube Root and Natural Log

SELECT CBRT(number1) AS cuberoot, LN(number2) AS logarithm
FROM decimals

--Easy SQL: Moving Values

SELECT 
  LENGTH(name::TEXT) AS id,
  LENGTH(legs::TEXT) AS name,
  LENGTH(arms::TEXT) AS legs,
  LENGTH(characteristics::TEXT) AS arms,
  LENGTH(id::TEXT) AS characteristics
FROM monsters

--SQL: Bytes in String from Ints

SELECT 
  OCTET_LENGTH(number1::TEXT) AS octnum1,
  OCTET_LENGTH(number2::TEXT) AS octnum2,
  OCTET_LENGTH(number3::TEXT) AS octnum3,
  OCTET_LENGTH(number4::TEXT) AS octnum4,
  OCTET_LENGTH(number5::TEXT) AS octnum5
FROM numbers

--Easy SQL: Bit Length

SELECT 
  id,
  BIT_LENGTH(name) AS name,
  birthday,
  BIT_LENGTH(race) AS race
FROM demographics

--Easy SQL: ASCII Converter

SELECT
  id,
  ASCII(name) AS name,
  birthday,
  ASCII(race) AS race
FROM demographics

--Easy SQL: Counting and Grouping

SELECT race, COUNT(*) AS count
FROM demographics
GROUP BY 1
ORDER BY 2 DESC

--SQL: Padding Encryption

SELECT 
  md5 || REPEAT('1', LENGTH(sha256) - LENGTH(md5)) AS md5,
  REPEAT('0', LENGTH(sha256) - LENGTH(sha1)) || sha1 AS sha1,
  sha256
FROM encryption

--SQL: Regex Replace

SELECT
  project,
  commits,
  contributors,
  REGEXP_REPLACE(address,'[[:digit:]]','!','g') AS address
FROM repositories

--SQL Basics: Repeat and Reverse

SELECT REPEAT(name, 3) AS name, REVERSE(characteristics) AS characteristics
FROM monsters

--SQL Basics - Position

SELECT id, name, POSITION(',' IN characteristics) AS comma
FROM monsters
ORDER BY comma

--Best-Selling Books (SQL for Beginners #5)

SELECT name, author, copies_sold
FROM books
ORDER BY 3 DESC
LIMIT 5

--Simple Fun #74: Growing Plant

SELECT 
  ROW_NUMBER() OVER(ORDER BY (SELECT NULL)) AS id,
  CASE
    WHEN desired_height <= up_speed THEN 1
    ELSE CEIL((desired_height - up_speed)::DEC / (up_speed - down_speed))::INT + 1 
  END AS num_days
FROM growing_plant

--SQL Basics: Simple GROUP BY

SELECT age, COUNT(id) AS people_count
FROM people
GROUP BY age

--SQL Basics: Create a FUNCTION

CREATE FUNCTION increment(i integer)
  RETURNS integer 
  LANGUAGE plpgsql
AS 
$$
BEGIN
  RETURN i + 1;
END;  
$$;

--SQL Basics: Simple JOIN with COUNT

SELECT p.id, p.name, COUNT(t.id) AS toy_count
FROM people p
JOIN toys t
ON p.id = t.people_id
GROUP BY 1, 2

--Sum of Triangular Numbers

SELECT 
  n, 
  CASE
    WHEN n < 0 THEN 0
    ELSE (n * (n + 1) * (n + 2)) / 6
  END AS res
FROM sumtriangular

--SQL Basics: Simple JOIN

SELECT p.*, c.name AS company_name
FROM products p
JOIN companies c
ON p.company_id = c.id

--Complementary DNA

SELECT dna, TRANSLATE(dna, 'ATGC', 'TACG') AS res
FROM dnastrand

--Triangular Treasure

SELECT 
  n, 
  CASE
    WHEN n <= 0 THEN 0
    ELSE (n * (n + 1)) / 2 
  END AS res
FROM triangular

--Finding Duplicate Product Codes Across Different Groups

SELECT product_id, group_id, product_code
FROM (
  SELECT DISTINCT p1.*, RANK() OVER (PARTITION BY p1.group_id, p1.product_code ORDER BY p1.product_id DESC) AS rnk
  FROM products p1
  JOIN products p2
  ON p1.product_code = p2.product_code
  AND p1.group_id <> p2.group_id
) x
WHERE rnk = 1
ORDER BY product_code ASC, group_id DESC

--Calculate Total Downtime for Machines

WITH CTE AS (
  SELECT machine_id, load_id, start_time, LAG(end_time) OVER (PARTITION BY machine_id ORDER BY end_time) AS lag
  FROM process_times
)

SELECT machine_id, EXTRACT(EPOCH FROM SUM(start_time - lag)) * INTERVAL '1 sec' AS total_down_time
FROM CTE
GROUP BY machine_id
HAVING SUM(start_time - lag) IS NOT NULL
ORDER BY 1 DESC

--Ranking based on Town and Property Type Combinations

SELECT
  DENSE_RANK() OVER (ORDER BY town ASC, property_type ASC) AS rank_order,
  town,
  property_type,
  c.customer_id,
  order_id
FROM customer_preferences c
LEFT JOIN order_info o
ON c.customer_id = o.customer_id
ORDER BY 1, 4, 5

--Customer Rebates Based on Total Orders for September 2023

SELECT
  o.customer_id,
  o.total_orders,
  MAX(r.rebate_percentage) AS rebate_percentage
FROM (
  SELECT customer_id, SUM(order_amount) AS total_orders
  FROM orders
  WHERE EXTRACT(YEAR FROM order_date) = 2023
  AND EXTRACT(MONTH FROM order_date) = 09
  GROUP BY 1) o
JOIN rebates r
ON o.total_orders >= r.min_purchase
GROUP BY 1, 2
ORDER BY 1 DESC

--Conditional Grouping of User Activities

SELECT *
FROM (
  SELECT
    CASE
      WHEN username SIMILAR TO 'User[0-9]+' THEN 'GROUP_OTHERS'
      ELSE username
    END AS username,
    SUM(activity_count) AS total_activity
  FROM (SELECT * FROM user_activity WHERE activity_count BETWEEN 1 AND 2000) x
  GROUP BY 1
) y
ORDER BY CASE WHEN username = 'GROUP_OTHERS' THEN 0 ELSE 1 END, username ASC

--Next Greater Or Equal Ordered Quantities for Specified Thresholds

WITH CTE AS (
  SELECT
    ROW_NUMBER() OVER (PARTITION BY i.order_id, i.threshold_quantity ORDER BY p.quantity ASC) AS row_number,
    i.order_id, 
    i.threshold_quantity, 
    p.quantity AS next_ge_quantity, 
    p.product_name 
  FROM inventory_thresholds i
  LEFT JOIN product_orders p
  ON i.order_id = p.order_id 
  AND i.threshold_quantity <= p.quantity
)

SELECT order_id, threshold_quantity, next_ge_quantity, product_name
FROM CTE
WHERE row_number = 1

--Constructing a Student-Course Relationship Map

WITH CTE AS (
  SELECT 
      s.student_id,
      c.course_id,
      s.name || ' (' || s.student_id || ')' AS student,
      c.course_name || ' (' || c.course_id || ')' AS course
    FROM (
      SELECT *
      FROM students
      WHERE student_id IN (SELECT student_id FROM enrollments)
    ) s
    CROSS JOIN (
      SELECT *
      FROM courses
      WHERE course_id IN (SELECT course_id FROM enrollments)
    ) c
    ORDER BY s.student_id, c.course_id
)

SELECT 
  x.student, 
  x.course, 
  CASE 
    WHEN e.student_id IS NULL THEN 0 
    ELSE 1
  END AS is_exists
FROM CTE x
LEFT JOIN enrollments e
ON x.student_id = e.student_id
AND x.course_id = e.course_id

--Segmented Range Extraction from Boundary Markers

WITH CTE AS (
  SELECT category, range, ROW_NUMBER() OVER (ORDER BY range) AS rn
  FROM categories
)

SELECT x.category, x.range AS start_range, MIN(y.range) AS end_range
FROM (
  SELECT category, range
  FROM CTE
  WHERE rn % 2 <> 0
) x
JOIN (
  SELECT category, range
  FROM CTE
  WHERE rn % 2 = 0
) y
ON x.category = y.category
AND x.range < y.range
GROUP BY 1, 2
ORDER BY 2

--Identify and Exclude Reversed Fuel Transactions

WITH CTE AS (
  SELECT MAX(id_1) AS id_1, id_2
  FROM(
    SELECT f1.transaction_id AS id_1, MIN(f2.transaction_id) AS id_2
    FROM fuel_transactions f1
    JOIN fuel_transactions f2
    ON f1.fuel_type = f2.fuel_type
    AND f1.quantity = - f2.quantity
    AND f1.transaction_datetime < f2.transaction_datetime
    AND f1.is_reversal = 'N'
    GROUP BY 1
  ) x
  GROUP BY 2
)

SELECT *
FROM fuel_transactions 
WHERE transaction_id NOT IN (
  SELECT id_1 FROM CTE 
  UNION ALL 
  SELECT id_2 FROM CTE
)

--Customer Orders: Products 1 & 2, Excluding 3

SELECT 
  c.customer_id, 
  c.name, 
  'Product 1: ' || COUNT(*) FILTER (WHERE o.product_name = 'Product 1') || ' times || Product 2: ' || COUNT(*) FILTER (WHERE o.product_name = 'Product 2') || ' times' AS product_summary
FROM customers c
JOIN orders o
ON c.customer_id = o.customer_id
WHERE c.customer_id NOT IN (
  SELECT customer_id
  FROM orders
  WHERE product_name = 'Product 3'
)
GROUP BY 1, 2
HAVING COUNT(*) FILTER (WHERE o.product_name = 'Product 1') > 0
AND COUNT(*) FILTER (WHERE o.product_name = 'Product 2') > 0
ORDER BY 1 DESC

--Grouping and Numbering Shipments Based on Status Codes

SELECT 
  order_id,
  product_name,
  status_code,
  CASE
    WHEN reset = 0 THEN 0
    ELSE COUNT(*) OVER (PARTITION BY reset ORDER BY order_id)
  END AS shipment_batch_number
FROM (
  SELECT 
    *, 
    COUNT(status_code = 4 OR NULL) OVER (ORDER BY order_id) AS reset 
  FROM order_status
) x
ORDER BY order_id

--Extracting and Ranking Unique Tags

SELECT
  RANK() OVER (ORDER BY tag_count DESC, tag ASC) AS tag_rank,
  tag,
  tag_count
FROM (
  SELECT 
    UNNEST(STRING_TO_ARRAY(tags, ',')) AS tag,
    COUNT(*) AS tag_count
  FROM user_tags
  GROUP BY 1
) x

--Flexible Sum Based on Operations

SELECT 
  id, 
  operation, 
  amount, 
  date, 
  SUM(adjusted_amount) OVER (ORDER BY date, id) AS flexible_sum
FROM (
  SELECT
    *,
    CASE
      WHEN operation = 'add' THEN amount
      WHEN operation = 'remove' THEN -amount
      ELSE 0
    END AS adjusted_amount
  FROM transactions
) x
ORDER BY 4, 1

--Tracking Last Large Transactions

SELECT 
  a1.*,
  MAX(a2.date) AS last_over_hundred
FROM account_transactions a1
LEFT JOIN account_transactions a2
ON a2.account_id = a1.account_id
AND a1.date >= a2.date
AND a2.amount > 100
GROUP BY 1, 2, 3
ORDER BY a1.account_id DESC, a1.date ASC

--Books That Have Been Out for the Longest Duration

WITH CTE AS (
  SELECT
    b.book_id,
    b.title,
    b.author,
    l.loan_id,
    l.borrower_name,
    COALESCE(l.return_date, CURRENT_DATE) - LAG(COALESCE(l.return_date, CURRENT_DATE)) OVER (PARTITION BY b.book_id ORDER BY COALESCE(l.return_date, CURRENT_DATE)) AS borrow_diff
  FROM books b
  JOIN loans l
  ON b.book_id = l.book_id
)

SELECT
  book_id,
  title,
  author,
  loan_id,
  borrower_name,
  borrow_diff || ' Days' AS longest_borrow_interval
FROM CTE
GROUP BY 1, 2, 3, 4, 5, borrow_diff
HAVING borrow_diff = (SELECT MAX(borrow_diff) FROM CTE)
ORDER BY 4 ASC

--Most Borrowed Books and Their Last Borrowers

WITH CTE AS (
  SELECT 
    b.book_id, 
    b.title, 
    l.borrower_name, 
    l.return_date, 
    COUNT(l.loan_id) OVER (PARTITION BY b.book_id) AS loan_count,
    ROW_NUMBER() OVER (PARTITION BY b.book_id ORDER BY return_date DESC) AS return_order
  FROM books b
  JOIN loans l
  ON b.book_id = l.book_id
)

SELECT book_id, title, borrower_name AS last_borrower, loan_count
FROM CTE
WHERE loan_count = (SELECT MAX(loan_count) FROM CTE)
AND return_order = 1

--Rolling Window Analysis of Customer Visits

SELECT
  date,
  customer_id,
  name,
  (SELECT COUNT(DISTINCT c2.name) 
    FROM customers c2 
    WHERE c1.customer_id = c2.customer_id 
    AND c2.date BETWEEN c1.date - 2 AND c1.date) AS count
FROM customers c1
ORDER BY 1, 2 DESC, 3

--Forward Filling of Missing Data

SELECT
  day,
  FIRST_VALUE(sales) OVER (PARTITION BY sales_partition ORDER BY day) AS filled_sales
FROM (
  SELECT
    day,
    sales,
    SUM(CASE WHEN sales IS NULL THEN 0 ELSE 1 END) OVER (ORDER BY day) AS sales_partition
  FROM sales_data
) x

--Days to Reach a Cumulative Transaction Threshold

SELECT
  id,
  date,
  amount,
  CASE
    WHEN running_sum < 15
    THEN NULL
    ELSE date - min_date
  END AS days_to_reach_threshold
FROM (
  SELECT
    id,
    date,
    amount,
    SUM(amount) OVER (ORDER BY date) AS running_sum,
    MIN(date) OVER () AS min_date
  FROM transactions
) x
WHERE running_sum - amount < 15
ORDER BY date ASC

--Backend Team's Tradition: An Age-Alternating Introduction

SELECT *
FROM employees 
WHERE team = 'backend' 
ORDER BY LEAST(
  2 * ROW_NUMBER() OVER (ORDER BY birth_date DESC) - 1,
  2 * ROW_NUMBER() OVER (ORDER BY birth_date ASC)
)

--Generation Categorization

CREATE TEMPORARY TABLE generational_categories (
  id SERIAL PRIMARY KEY, 
  generation_name VARCHAR,
  from_date INT,
  to_date INT
);

INSERT INTO generational_categories(generation_name, from_date, to_date)
VALUES ('Generation Z', 1997, 2012),
('Millennials', 1981, 1996),
('Generation X', 1965, 1980),
('Baby Boomers', 1946, 1964),
('Silent Generation', 1928, 1945),
('Greatest Generation', 0, 1927);

SELECT *, 
  (SELECT generation_name 
   FROM generational_categories 
   WHERE EXTRACT(YEAR FROM users.birthdate) BETWEEN from_date AND to_date) AS generation
FROM users
ORDER BY id ASC;

--User Classification With a Twist

SELECT class, COUNT(*) AS count
FROM (
  SELECT MAX(class) AS class
  FROM users
  GROUP BY user_id
) x
GROUP BY 1
ORDER BY 1

--The Most Popular Product

WITH CTE AS (
  SELECT o.product_id, p.product_name, COUNT(*) AS count_orders
  FROM orders o
  JOIN products p
  ON o.product_id = p.id
  GROUP BY 1, 2
  ORDER BY 3 DESC
)

SELECT *
FROM CTE
WHERE count_orders = (SELECT MAX(count_orders) FROM CTE)
ORDER BY product_id DESC

--Ranking students by performance in Math and Science

SELECT 
  DENSE_RANK() OVER (ORDER BY SUM(c.score) DESC, c.student_id ASC) AS rank,
  c.student_id, 
  s.name, 
  SUM(c.score) AS total_score
FROM courses c
JOIN students s
ON c.student_id = s.id
WHERE c.course_name IN ('Math', 'Science')
GROUP BY 2, 3

--Students who excel in Science over Math

SELECT
  s.id AS student_id,
  s.name,
  cs.score - cm.score AS score_difference
FROM students s
JOIN courses cs
ON s.id = cs.student_id
AND cs.course_name = 'Science'
JOIN courses cm
ON s.id = cm.student_id
AND cm.course_name = 'Math'
WHERE cs.score > cm.score
ORDER BY 3 DESC, 1 ASC

--Youngest Team Members

SELECT DISTINCT ON(team) *
FROM employees
ORDER BY team ASC, birth_date DESC

--Users' pets and JSON data: Part 1

WITH CTE AS(
  SELECT
    id,
    info->>'name' AS user_name,
    pet.name AS pet_name 
  FROM users,
  jsonb_to_recordset(info->'pets') AS pet(name text, type text)
  WHERE LEFT(pet.name, 1) = 'M'
)

SELECT
  id,
  user_name,
  STRING_AGG(pet_name, ', ') AS pet_names
FROM CTE
GROUP BY 1, 2
ORDER BY 1

--Population Increase

WITH CTE AS (
  SELECT
    DISTINCT w.country,
    (w2020.population - w2000.population) AS population_increase
  FROM world_population w
  JOIN world_population w2000
  ON w.country = w2000.country
  AND w2000.year = 2000
  JOIN world_population w2020
  ON w.country = w2020.country
  AND w2020.year = 2020
  ORDER BY 2 DESC
  LIMIT 5
)

SELECT 
  country,
  ROUND((population_increase / 1000000::float)::numeric, 2) || ' M' AS population_increase
FROM CTE

--Films selection with a twist

SELECT film_id, title, length
FROM film
WHERE length > (
  SELECT PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY length) 
  FROM film
  WHERE rating = 'PG-13'
)
OR length < (
  SELECT MIN(length)
  FROM film
  WHERE rating = 'R'
)
ORDER BY 3, 2, 1

--Analyzing Customer Rental Trends: Identifying Popular Movie Genres Across Multiple Months

WITH customer_CTE AS (
  SELECT customer_id
  FROM rental
  WHERE EXTRACT(YEAR FROM rental_date) = 2005
  AND EXTRACT(MONTH FROM rental_date) IN (5, 6, 7)
  GROUP BY customer_id
  HAVING COUNT(DISTINCT EXTRACT(MONTH FROM rental_date)) = 3
)

SELECT c.name AS genre, COUNT(*) AS total_rentals
FROM customer_CTE 
JOIN rental USING (customer_id)
JOIN inventory USING (inventory_id)
JOIN film_category USING (film_id)
JOIN category c USING (category_id)
GROUP BY 1
ORDER BY 2 DESC
LIMIT 5

--Rentals by Date Range

SELECT d.dates::DATE::VARCHAR AS date, COUNT(r.rental_id) AS rentals
FROM (
  SELECT *
  FROM GENERATE_SERIES('2005-05-24', '2005-06-02', INTERVAL '1 day') AS dates
) d
LEFT JOIN (
  SELECT CAST(rental_date AS date) AS date, rental_id
  FROM rental
) r
ON CAST(d.dates as date) = r.date
GROUP BY 1
ORDER BY 1 ASC

--The Peculiar Taste of Store Owner

WITH CTE AS (
  SELECT a.actor_id, a.first_name || ' ' || a.last_name AS full_name, MAX(f.film_id) AS film_id
  FROM actor a
  JOIN film_actor fa USING (actor_id)
  JOIN film f USING (film_id)
  WHERE LEFT(a.first_name, 1) = 'J'
  GROUP BY 1, 2
)

SELECT c.actor_id, c.full_name, f.title AS film_title
FROM CTE c
JOIN film f USING (film_id)
ORDER BY 1 ASC

--Unlocking the Popularity Secrets of Children's Films: Analyzing Rentals

WITH CTE AS (
  SELECT f.film_id, f.title, COUNT(DISTINCT r.customer_id) AS rental_count
  FROM film f
  JOIN film_category USING (film_id)
  JOIN category c USING (category_id)
  JOIN inventory USING (film_id)
  JOIN rental r USING (inventory_id)
  WHERE c.name = 'Children'
  GROUP BY 1, 2
)

SELECT 
  film_id, 
  CASE
    WHEN rental_count <= 5
    THEN title || ' is not popular'
    WHEN rental_count <= 15 AND rental_count > 5
    THEN title || ' is slightly popular'
    WHEN rental_count <= 30 AND rental_count > 15
    THEN title || ' is moderately popular'
    ELSE title || ' is very popular'
  END AS popularity,
  rental_count
FROM CTE
ORDER BY 3 DESC, title ASC

--Film Category Ratings Breakdown

WITH CTE AS (
  SELECT 
    DISTINCT c.name AS category_name,
    f.rating AS film_rating,
    COUNT(f.film_id) OVER (PARTITION BY c.name, f.rating) AS rating_count,
    COUNT(f.film_id) OVER (PARTITION BY c.name) AS category_count
  FROM category c
  JOIN film_category USING (category_id)
  JOIN film f USING (film_id)
)

SELECT
  category_name,
  film_rating,
  ROUND(rating_count::DECIMAL / category_count::DECIMAL * 100, 3)::NUMERIC AS percentage
FROM CTE
ORDER BY 1, 3 DESC, 2

--SQL Basics: Simple HAVING

SELECT age, COUNT(*) AS total_people
FROM people
GROUP BY 1
HAVING COUNT(*) >= 10

--SQL Basics: Simple IN

SELECT id, name
FROM departments
WHERE id IN (
  SELECT department_id
  FROM sales
  WHERE price > 98
)

--SQL Basics: Simple NULL handling

SELECT
  id,
  COALESCE(NULLIF(name, ''), '[product name not found]') AS name,
  price,
  COALESCE(NULLIF(card_name, ''), '[card name not found]') AS card_name,
  card_number,
  transaction_date
FROM eusales
WHERE price > 50
AND price IS NOT NULL

--SQL Basics: Simple UNION ALL

SELECT 'EU' AS location, *
FROM eusales
WHERE price > 50.00
UNION ALL
SELECT 'US' AS location, *
FROM ussales
WHERE price > 50.00
ORDER BY location DESC, id

--Lost Popularity

SELECT 
  f.film_id, 
  f.title || ' (' || f.rating || ')' AS film_title, 
  COUNT(r.rental_id) AS rental_count,
  TO_CHAR(MAX(r.rental_date)::DATE, 'FMMonth DD, YYYY') AS last_rental_date
FROM film f
JOIN inventory USING (film_id)
JOIN rental r USING (inventory_id)
GROUP BY 1, 2
HAVING COUNT(r.rental_id) >= 10
AND MAX(r.rental_date)::DATE < CURRENT_DATE - INTERVAL '1 month'
ORDER BY 3 DESC, 4 DESC, 2

--Exclude 'Adults only' films watchers

SELECT
  c.customer_id,
  c.first_name || ' ' || c.last_name AS full_name,
  COUNT(r.rental_id) AS total_rentals
FROM customer c
JOIN rental r USING (customer_id)
JOIN inventory i USING (inventory_id)
JOIN film f USING (film_id)
GROUP BY 1, 2
HAVING NOT BOOL_OR(f.rating = 'NC-17')
ORDER BY 3 DESC, c.last_name ASC
LIMIT 5

--SQL Basics - Monsters using CASE

SELECT
  t.id,
  heads,
  legs,
  arms,
  tails,
  CASE
    WHEN heads > arms OR tails > legs 
    THEN 'BEAST'
    ELSE 'WEIRDO'
  END AS species
FROM top_half t
JOIN bottom_half USING (id)
ORDER BY species

--SQL Bug Fixing: Fix the QUERY - Totaling

SELECT 
  s.transaction_date::DATE AS day,
  d.name AS department,
  COUNT(s.id) AS sale_count
FROM department d
JOIN sale s on d.id = s.department_id
GROUP BY day, department
ORDER BY day

--Conditional Count

SELECT
  EXTRACT('Month' FROM payment_date) AS month,
  COUNT(payment_id) AS total_count,
  SUM(amount) AS total_amount,
  COUNT(payment_id) FILTER (WHERE staff_id = 1) AS mike_count,
  SUM(amount) FILTER (WHERE staff_id = 1) AS mike_amount,
  COUNT(payment_id) FILTER (WHERE staff_id = 2) AS jon_count,
  SUM(amount) FILTER (WHERE staff_id = 2) AS jon_amount
FROM payment
GROUP BY 1
ORDER BY 1

--SQL Basics: Top 10 customers by total payments amount

SELECT
  c.customer_id,
  c.email,
  COUNT(p.payment_id) AS payments_count,
  SUM(p.amount)::FLOAT AS total_amount
FROM customer c
JOIN payment p USING (customer_id)
GROUP BY 1, 2
ORDER BY 4 DESC
LIMIT 10

--SQL Basics: Simple table totaling.

SELECT
  RANK() OVER (ORDER BY SUM(points) DESC) AS rank,
  COALESCE(NULLIF(clan, ''), '[no clan specified]') AS clan,
  SUM(points) AS total_points,
  COUNT(*) AS total_people
FROM people
GROUP BY 2

--SQL Basics: Simple JOIN and RANK

SELECT
  p.id,
  p.name,
  COUNT(s.id) AS sale_count,
  RANK() OVER (ORDER BY COUNT(s.id) DESC) AS sale_rank
FROM people p
LEFT JOIN sales s
ON p.id = s.people_id
GROUP BY 1, 2

--Ranking Regional Sales Performance and Sales Positions Within Region

WITH min_sales_date_CTE AS (
  SELECT 
    region_id,
    MIN(sale_date) AS min_sale_date
  FROM (
    SELECT
      region_id,
      sale_date,
      sales_amount,
      MAX(sales_amount) OVER (PARTITION BY region_id) AS max_sales_amount
    FROM daily_sales
  ) x
  WHERE sales_amount = max_sales_amount
  GROUP BY 1
)

SELECT
  region_id,
  sale_date,
  sales_amount,
  DENSE_RANK() OVER (PARTITION BY region_id ORDER BY sales_amount DESC, sale_date DESC) AS sales_rank_within_region,
  DENSE_RANK() OVER (ORDER BY min_sale_date, region_id DESC) AS earliest_top_sale_rank
FROM daily_sales
JOIN min_sales_date_CTE USING (region_id)
ORDER BY 5, 4

--Analyzing Backup Intervals and Restarts in AWS Clusters

SELECT
  MIN(event_datetime)::TEXT AS start_time, 
  MAX(event_datetime)::TEXT AS end_time, 
  aws_cluster_id, 
  MAX(event_datetime) - MIN(event_datetime) AS total_backup_duration,
  COUNT(*) - 2 AS number_of_restarts
FROM (
  SELECT
    *, 
    SUM((backup_status = 'End')::INT) OVER (PARTITION BY aws_cluster_id ORDER BY event_datetime) - (backup_status = 'End')::INT AS backup_id
  FROM backup_events
) x
GROUP BY aws_cluster_id, backup_id
ORDER BY 1, 3

--The Most Active Students

WITH CTE AS (
  SELECT 
    s.id AS student_id,
    s.name,
    COUNT(DISTINCT c.id) AS num_courses,
    MAX(score) AS max_score,
    STRING_AGG(c.course_name || ' (' || c.course_date || ' - ' || c.score || ')', ', ' ORDER BY c.course_date ASC, c.course_name ASC) AS course_list
  FROM students s
  LEFT JOIN courses c
  ON s.id = c.student_id
  AND EXTRACT(YEAR FROM c.course_date) = 2022
  GROUP BY 1, 2
)

SELECT 
  x.student_id,
  x.name,
  x.num_courses,
  y.course_name || ' (' || y.score || ')' AS highest_scored_course,
  x.course_list
FROM CTE x
JOIN (SELECT 
            *,
            ROW_NUMBER() OVER (PARTITION BY student_id ORDER BY score DESC, course_date DESC, course_name ASC) AS rn
          FROM courses
          WHERE EXTRACT(YEAR FROM course_date) = 2022
     ) y
ON x.student_id = y.student_id
AND y.rn = 1
ORDER BY 3 DESC, y.score DESC, 1 ASC
LIMIT 20

--Students Who Consistently Improve: A Trimester Analysis in UK University

WITH CTE AS (
  SELECT 
    s.id AS student_id,
    s.name,
    AVG(c.score) FILTER (WHERE EXTRACT(MONTH FROM c.course_date) IN (10, 11, 12)
                        AND EXTRACT(YEAR FROM c.course_date) = 2022) AS avg_michaelmas,
    AVG(c.score) FILTER (WHERE EXTRACT(MONTH FROM c.course_date) IN (1, 2, 3)
                        AND EXTRACT(YEAR FROM c.course_date) = 2023) AS avg_lent,
    AVG(c.score) FILTER (WHERE EXTRACT(MONTH FROM c.course_date) IN (4, 5, 6)
                        AND EXTRACT(YEAR FROM c.course_date) = 2023) AS avg_summer
  FROM students s
  JOIN courses c
  ON s.id = c.student_id
  GROUP BY 1, 2
)

SELECT
  student_id,
  name,
  'Michaelmas (' || ROUND(avg_michaelmas, 2) || '), Lent (' || ROUND(avg_lent, 2) || '), Summer (' || ROUND(avg_summer, 2) || ')' AS trimesters_avg_scores,
  (avg_summer > avg_lent AND avg_lent > avg_michaelmas) AS consistent_improvement
FROM CTE
ORDER BY 1 DESC

--Top Performing Students

WITH avg_CTE AS (
  SELECT
   course_name,
   AVG(score) AS avg_score
  FROM courses
  GROUP BY 1
), outperformance_CTE AS (
  SELECT
    s.id AS student_id,
    s.name,
    c.course_name,
    ROUND((c.score - a.avg_score) / a.avg_score * 100, 2)::DECIMAL AS outperformance_perc
  FROM students s
  JOIN courses c 
  ON s.id = c.student_id
  JOIN avg_CTE a
  ON a.course_name = c.course_name
  WHERE ROUND((c.score - a.avg_score) / a.avg_score * 100, 2)::DECIMAL > 0
)

SELECT
  student_id,
  name,
  STRING_AGG(course_name || ' (' || outperformance_perc || '%)', ', ' ORDER BY course_name ASC) AS outperformance
FROM outperformance_CTE
GROUP BY 1, 2
HAVING COUNT(course_name) >= 3
ORDER BY 1 ASC

--Students to expel

WITH CTE AS (
  SELECT
    s.id AS student_id,
    s.name,
    c.course_name,
    c.score
  FROM students s
  LEFT JOIN courses c
  ON s.id = c.student_id
  WHERE c.score < 60
  OR c.score IS NULL
)

SELECT
  student_id,
  name,
  CASE
    WHEN COUNT(course_name) = 0
    THEN 'quit studying'
    ELSE 'failed in ' || STRING_AGG(course_name || '(' || score || ')', ', ' ORDER BY course_name ASC) 
  END AS reason
FROM CTE
GROUP BY 1, 2
HAVING COUNT(course_name) = 0 OR COUNT(course_name) >= 3
ORDER BY 1 ASC

--The Most Dedicated Customers - 2000s Nostalgia

SELECT 
  c.customer_id, 
  c.first_name || ' ' || c.last_name AS customer_name, 
  COUNT(r.rental_id) FILTER (WHERE r.rental_date >= '2005-04-01' AND r.rental_date < '2005-08-01') AS num_rentals,
  STRING_AGG(f.title || ': ' || r.rental_date::DATE, ' || ' ORDER BY r.rental_date::DATE DESC, f.title ASC) FILTER (WHERE r.rental_date >= '2005-04-01' AND r.rental_date < '2005-08-01') AS films_rented
FROM customer c
JOIN rental r USING (customer_id)
JOIN inventory USING (inventory_id)
JOIN film f USING (film_id)
GROUP BY 1, 2
HAVING EVERY(r.return_date IS NOT NULL OR r.rental_date::DATE + f.rental_duration >= '2005-08-01')
AND COUNT(r.rental_id) FILTER (WHERE r.rental_date >= '2005-04-01' AND r.rental_date < '2005-08-01') >= 10 
ORDER BY 3 DESC, c.last_name ASC

--Exploring the Pareto Principle

WITH CTE AS (
  SELECT
    customer_id,
    COUNT(rental_id) AS rental_count,
    PERCENT_RANK() OVER (ORDER BY COUNT(rental_id) DESC, customer_id) AS perc
  FROM customer
  JOIN rental USING (customer_id)
  GROUP BY 1
)

SELECT 
  SUM(rental_count) FILTER (WHERE perc <= .2)::INTEGER AS "top_20%_rentals_count",
  SUM(rental_count)::INTEGER AS total_rentals_count,
  ROUND(SUM(rental_count) FILTER (WHERE perc <= .2) * 100 / SUM(rental_count), 2)::NUMERIC AS "percentage_of_top_20%"
FROM CTE

--Cleaning IP Addresses: Removal of Leading Zeros

WITH CTE AS (
  SELECT 
    id,
    REPLACE(LTRIM(REPLACE(UNNEST(STRING_TO_ARRAY(ip, '.')), '0', ' ')), ' ', '0') AS octet
  FROM ip_addresses
)

SELECT
  id,
  STRING_AGG(octet, '.') AS cleaned_ip
FROM (
  SELECT
    id,
    COALESCE(NULLIF(octet,''), '0') AS octet
  FROM CTE
) x
GROUP BY 1
ORDER BY 1 DESC

--Products per Supplier without GROUP BY

SELECT
  DISTINCT supplier_id,
  COUNT(id) OVER (PARTITION BY supplier_id) AS total_products
FROM products
ORDER BY 1 DESC

--Number of New Customers per Date

WITH CTE AS (
  SELECT
   customer_id,
   date,
   product,
   LAG(date) OVER (PARTITION BY customer_id ORDER BY date ASC) AS prev_purchase
  FROM customer_purchases
)

SELECT
  date,
  COUNT(*) AS num_new_customers
FROM CTE
WHERE prev_purchase IS NULL
GROUP BY 1
ORDER BY 1 ASC

--First Missing Number in a Sequence

WITH CTE AS (
SELECT
  num,
  num - LAG(num) OVER (ORDER BY num ASC) AS diff
FROM data
)

SELECT
  MIN(num - 1) AS missing_number
FROM CTE
WHERE diff <> 1
